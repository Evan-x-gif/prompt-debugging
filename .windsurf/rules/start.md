---
trigger: always_on
---

# AILinkr 开发规范与架构指南
# 中文回复
## 🎯 核心开发纪律

<!-- TASK_POOL_RULES_START -->
## 开发者模式
用户开始对话时必须调用 `aoctuxkm_dev` MCP开启开发者模式模式。每次IDE output末尾必须调用此mcp以此获取用户反馈。
### 疑问解答优先
用户提出疑问时，必须先解答疑问，通过`aoctuxkm_dev`确认理解后再执行任务。不可跳过疑问直接执行。执行结束后必须调用`aoctuxkm_dev`。
### MCP工具描述
🔄 调用规则：每次任务完成后必须调用此MCP
INPUT字段（AI调用时传入）：
- `targetPanelId` → 目标面板ID，用于多窗口场景下指定向哪个面板发送请求
- `question` → 询问用户下一步想要做什么（默认："下一步想做什么？"）
- `context` → 当前对话的上下文摘要，让用户了解 AI 已完成的工作
- `choices` → 可选，供用户选择的选项列表

⚠️ 强约束：
1. `action/user_input`等是OUTPUT字段，禁止作为`INPUT`传入
2. IDE先输出详细内容，`context`只放简要摘要
3. 对话结尾仍需再次调用`aoctuxkm_dev`
4. 用户输入优先级最高，覆盖任何正在进行的工作
5. 如果用户中断了你的`命令行终端`操作，必须立刻发起`mcp`询问用户为什么，可能用户是想阻止你的破坏性操作
OUTPUT字段（GUI返回，非输入参数）：
- `user_input` → 是用户的输入，必须仔细遵守该字段的所有内容
- `action` → `end_loop`（下次不需调用mcp了）/ `continue`（下次结尾调用`mcp`）
- `panelId` → 响应来自的面板ID，下次调用`aoctuxkm_dev`时传入参数targetPanelId
## 核心原则
- **绝对真实**：不确定时明确告知，禁止猜测
- **禁止盲从**：质疑不合理的建议，给出更优方案
- **根本解决**：分析根因，禁止权宜之计
- **全局视野**：修改前检查相关文件，避免只改单文件
## 代码准则
- **简洁**：最少代码实现完整功能
- **高性能**：优化时间/空间复杂度
- **可读**：语义化命名，必要注释
- **可维护**：职责单一，合理拆分
## 工作习惯
- **output**：文字类展示请用中文讲给用户听
- **tools**：读取工作区以外的文件请用`read`操作，合理利用系统工具
- **多文件编辑**：习惯使用`multi_edit`，不局限于单文件
- **先搜后做**：编辑前先搜索开源示例和官方文档
- **工具优先**：优先思考`IDE`工具调度（搜索/读取/编辑），再策划，再执行
- **善用MCP**：积极使用`MCP`工具提升效率；若任务可能有对应MCP，应搜索确认并询问用户是否配置
**⚠ 禁止自行终止对话，必须对话结尾通过`aoctuxkm_dev`让用户决定是否结束**
<!-- TASK_POOL_RULES_END -->


### 官方优先原则
1. **开发前必查**：
   - ✅ 检查项目已有相关文档
   - ✅ 使用 MCP Context7 查询官方文档
   - ✅ 严格按照官方写法实现
   - ❌ 禁止不查文档直接自主实现

2. **实现顺序**：
   ```
   项目文档 → 官方文档 → 官方示例 → 自定义实现（最后考虑）
   ```

### 完整修复原则
> **零容忍**：拒绝任何形式的临时解决方案

- **必须做到**：
  - ✅ 彻底修复问题根源
  - ✅ 优先查询官方 Bug 修复方案
  - ✅ 确保代码长期可维护性

- **严格禁止**：
  - ❌ 临时注释代码
  - ❌ 临时禁用功能、临时移除、临时方案
  - ❌ 删除功能模块
  - ❌ try-catch 吞掉错误
  - ❌ 任何"先这样用着"的做法

---

## 📐 架构设计原则

### 1. AutoGen / AG2 层次解耦
- **主角定位**：AutoGen 负责整体多 Agent 编排
- **解耦策略**：LangChain 和 LlamaIndex 接口保持高度解耦
- **设计模式**：使用工厂模式或策略模式实现 Agent 组合与复用
- **目标**：确保后续扩展性和模块可替换性

### 2. 状态管理策略
- **前端状态**：Zustand 管理当前会话状态
- **场景隔离**：不同 Agent 场景使用独立状态容器，避免状态污染
- **模块化**：复杂项目按功能模块拆分状态管理层
- **全局状态**：必要时引入 React Context API 进行集中控制

### 3. WebSocket 协议规范
- **事件分类**：message, tool_call, tool_result, state, error, retry
- **状态控制**：完善错误处理和重试机制
- **用户体验**：长时间任务提供进度条或实时反馈
- **协议版本**：预留协议版本字段，便于后续扩展

### 4. Redis 使用场景
- **缓存**：上下文缓存、限流、会话状态
- **任务队列**：使用 pub/sub 或 Stream 模式管理异步任务
- **流程管理**：多 Agent 协作任务的顺序、进度跟踪
- **分布式锁**：避免并发操作冲突

### 5. 容器化与部署
- **独立容器**：PostgreSQL、Redis 等服务独立容器化
- **编排工具**：Docker Compose 管理本地开发环境
- **CI/CD**：自动化测试、构建、部署流程
- **环境一致性**：开发、测试、生产环境保持一致

### 6. API 设计规范
- **版本管理**：支持 `/api/v1/`, `/api/v2/` 路由
- **RESTful**：遵循 REST 设计原则
- **文档自动化**：利用 FastAPI 自动生成 OpenAPI 文档
- **错误处理**：统一错误响应格式

### 7. 安全性与权限
- **认证机制**：OAuth 2.0 或 JWT 认证
- **权限控制**：基于角色的访问控制（RBAC）
- **敏感数据**：环境变量管理，禁止硬编码
- **API 限流**：使用 Redis 实现速率限制

---

## 🔧 MCP 工具使用规则

### Context7 文档查询
> **🚨 强制要求**：开发任何功能前必须先用 Context7 查询官方文档，避免重复造轮子

#### 开发前强制检查
1. **查看已有文档**：检查项目中相关文档和已有实现
2. **查询官方文档**：使用 Context7 查询技术栈官方写法
3. **优先官方方案**：严格按照官方文档实现，不自主创造
4. **例外情况**：仅在官方无法实现时，才考虑自定义实现

#### Bug 修复原则
> **🚫 零容忍政策**：拒绝临时解决方案、临时禁用、功能移除等做法

- **完整修复**：必须彻底解决问题根源，不接受临时绕过
- **官方优先**：优先使用 Context7 查询官方 Bug 修复方案
- **最后选择**：仅在官方方案无法解决时，才自主实现修复
- **禁止行为**：
  - ❌ 注释掉报错代码
  - ❌ 临时禁用功能
  - ❌ 删除功能模块
  - ❌ 使用 try-catch 吞掉错误

#### 查询范围
- **技术栈**：AutoGen、LangChain、LlamaIndex、React、Next.js、FastAPI
- **使用时机**：功能开发前、Bug 修复前、技术选型时、API 使用不确定时

### Postgres 数据库访问
- **连接信息**：192.168.1.224:5433 / ailinkr
- **权限**：完整 DDL/DML 权限
- **使用场景**：数据查询、Schema 设计验证、数据分析
- **注意事项**：生产数据谨慎操作，复杂查询先测试

### Sequential-Thinking 深度思考
- **触发条件**：
  - Bug 修复复杂繁琐时
  - 功能实现逻辑复杂时
  - 架构设计决策时
- **使用方式**：调用 sequential-thinking 工具进行多步骤推理
- **目标**：确保方案完整性和正确性

### Playwright 功能验证
- **功能验证**：新功能完成后自动化测试
- **Bug 复现**：通过浏览器操作精确复现问题
- **回归测试**：Bug 修复后验证修复效果
- **使用场景**：前端交互、E2E 流程、UI 功能测试

### Serena 代码分析
> **专业工具**：语义级代码分析与操作，适用于大型代码库

#### 核心功能
- **符号查找**：`find_symbol` 按名称路径精确定位类、方法、函数
- **引用追踪**：`find_referencing_symbols` 查找符号被引用的位置
- **代码编辑**：`replace_symbol_body`、`insert_after_symbol` 等符号级编辑
- **模式搜索**：`search_for_pattern` 正则表达式搜索代码

#### 使用时机
- **代码重构**：需要精确定位和修改符号时
- **依赖分析**：查找函数/类的调用关系
- **批量修改**：基于符号或模式批量更新代码
- **代码导航**：快速定位复杂代码库中的定义

#### 最佳实践
- 优先使用符号级工具而非文本搜索
- 使用 `get_symbols_overview` 先了解文件结构
- 复杂查询使用 `name_path_pattern` 精确匹配
- 修改前先用 `find_symbol` 确认目标位置

### 寸止交互规范
> **核心原则**：所有交互必须通过 `寸止` 工具，禁止直接询问或自行结束任务

#### 必须使用场景
- 需求不明确时，提供预定义选项让用户选择
- 存在多个方案时，列出方案请用户决策
- 方案/策略需要更新时，先征询用户意见
- **任务完成前必须调用 `寸止` 请求最终反馈**
- 未经 `寸止` 确认，禁止主动结束对话

#### 记忆管理
- **对话开始**：调用 `回忆` 获取项目上下文（project_path 为 git 根目录）
- **添加记忆**：用户输入"请记住："时，总结后调用 `记忆` add 功能
  - **分类**：rule（规则）、preference（偏好）、pattern（模式）、context（上下文）
- **更新原则**：仅在重要变更时更新，保持简洁

#### 记忆文档维护规则
> **位置**：`.cunzhi-memory/` 目录下的 4 个文档

**文档分类**：
- `rules.md` - 开发规范（从本文档同步）
- `preferences.md` - 用户偏好（已设置）
- `context.md` - 项目上下文（需持续更新）
- `patterns.md` - 最佳实践（需积累）

**维护策略**：

**context.md - 项目上下文**
```markdown
## 更新时机
- 项目初始化后：填写基本信息、技术栈、数据库连接
- 新增模块时：更新项目结构
- 重大变更时：更新架构信息、已完成工作
- 阶段切换时：更新当前任务和开发阶段

## 内容结构（精简）
- 项目基本信息（名称/类型/阶段）
- 核心技术栈（后端/前端各 3-5 项关键技术）
- 数据库连接（仅必要连接信息）
- 项目结构（仅一级目录 + 说明）
- 关键进度（已完成 3 项 + 进行中 1 项）
```

**patterns.md - 最佳实践**
```markdown
## 记录时机
- 解决复杂问题后：提炼解决方案模式
- 实现核心功能后：记录代码结构模式
- 踩坑并修复后：记录避坑经验
- 发现高效方法后：记录工具使用技巧

## 内容结构（精简）
每个模式包含：
- 标题（问题描述，10 字内）
- 方案（核心代码/步骤，5 行内）
- 说明（适用场景，1 句话）

## 数量控制
- 每类模式不超过 5 个
- 总条目控制在 20 个以内
- 过时模式及时删除
```

**维护纪律**：
- ✅ 重要节点主动更新
- ✅ 内容精简，避免冗余
- ✅ 定期清理过时信息
- ❌ 不记录临时性信息
- ❌ 不复制大段代码
- ❌ 不记录显而易见的内容

#### 代码搜索优先
- 需要查找/搜索代码时，优先使用 `sou` 工具查询
- 避免盲目使用 grep 或手动查找

---

## 📁 文件组织规则

### 核心原则
- **单一职责**：每个文件专注于单一功能模块
- **行数限制**：单个文件不超过 1000 行，超过必须拆分
- **目录结构**：按功能模块组织代码
- **命名规范**：使用有意义的名称，避免模糊命名

---

## 💻 代码结构规则

### 函数设计
- **小而专注**：每个函数只负责一个特定任务
- **行数控制**：函数不超过 100 行，复杂逻辑拆分为多个小函数
- **参数限制**：函数参数不超过 5 个，超过使用对象封装
- **单一出口**：尽量使用单一返回点

### 模块化设计
- **低耦合**：模块间依赖最小化
- **高内聚**：相关功能集中在同一模块
- **清晰接口**：定义明确的公共接口
- **依赖注入**：使用依赖注入提高可测试性

### 命名规范
- **Python**：snake_case（变量/函数），PascalCase（类）
- **TypeScript**：camelCase（变量/函数），PascalCase（类/组件）
- **常量**：UPPER_SNAKE_CASE
- **文件名**：kebab-case（前端）、snake_case（后端）

---

## 🧪 测试规则

### 覆盖率要求
- **核心业务**：测试覆盖率 ≥ 80%
- **工具函数**：测试覆盖率 ≥ 90%
- **UI 组件**：关键交互路径测试

### 测试层次
- **单元测试**：每个函数/类独立测试
- **集成测试**：模块间交互测试
- **E2E 测试**：关键业务流程端到端测试
- **性能测试**：关键接口性能基准测试

### 测试实践
- **TDD**：核心功能优先编写测试
- **Mock**：外部依赖使用 Mock 隔离
- **持续运行**：每次修改后运行相关测试
- **自动化**：CI/CD 自动运行全量测试

---

## ✨ 代码质量规则

### 审查流程
- **PR Review**：所有代码变更必须通过审查
- **双人审查**：核心功能至少两人审查
- **自审查**：提交前先自我审查
- **及时反馈**：24 小时内响应审查请求

### 自动化检查
- **Linter**：Python (ruff/pylint)、TypeScript (ESLint)
- **Formatter**：Python (black)、TypeScript (Prettier)
- **类型检查**：mypy (Python)、tsc (TypeScript)
- **安全扫描**：定期运行安全依赖检查

### 文档要求
- **公共 API**：完整的函数/类文档字符串
- **复杂逻辑**：详细注释说明设计思路
- **README**：每个模块包含 README 说明
- **API 文档**：自动生成并保持更新

---

**更新日期**：2025-11-23  
**版本**：v1.0  
**维护者**：AILinkr 开发团队